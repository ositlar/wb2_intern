<h3>1. Какой самый эффективный способ конкатенации строк?</h3>
<br>Есть 2 способа конкатенации строк: оператор + и strings.Builder
Конкатенация через оператор + является более медленым способом
Более быстрым способом является конкатенация через strings.Builder.
Производительность этого способа можно еще больше повысить щи пред-алокации методом Grow
<br>Например:
<br>str1 := "3453534524gd"
<br>str2 := "ilusedety34978"
<br>var builder strings.Builder
<br>builder.Grow(len(str1) + len(str2))
<br>builder.WriteString(x)
<br>builder.WriteString(y)
<br>result := builder.String()
<br>
<h3>2. Что такое интерфейсы, как они применяются в Go?</h3>
<br>Интерфейсы в Go — это своего рода определение. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.
<br>Интерфейсы используют для:
<br>1. Уменьшение дублирования и сокращения шаблонного кода
<br>2. Облегчают использования в модульных тестах зашлушек вместо реаьных объектов
<br>3. Помогают отвязывать части кодовой базы, то есть методы и структуры могут быть привязанны не к конкретному типу, а к типу, который реализует определенный интерфейс.
<h3>3. Чем отличаются RWMutex от Mutex?</h3>
<br> Cинтаксис и использование RWMutex аналогичны Mutex за исключением того, что у него есть два дополнительных метода: RLock() и RUnlock().
<br>RLock() получает общую блокировку (для чтения), позволяя нескольким программам читать ресурс одновременно.
<br>RUnlock() снимает блокировку общего доступа (чтения).
<h3>4. Чем отличаются буферизированные и не буферизированные каналы?</h3>
<br>Буферизация канала означает, что данные, посланные в канал, сохраняются в его внутреннем буфере, если принимающая сторона еще не готова их принять. Это позволяет отправителю продолжать отправку данных, не ожидая, пока они будут приняты, и уменьшает количество необходимого копирования данных.
<br>Небуферизированные каналы не имеют такого буфера, и каждая отправка данных должна быть немедленно принята другой стороной. Э
<h3>5. Какой размер у структуры struct{}{}?</h3>
<br> Размер struct{}{} равен 0
<h3>6. Есть ли в Go перегрузка методов или операторов?</h3>
<br> В Go отсутсвует перегрузка методов и операндов
<br>В Go каждый метод и оператор имеет уникальное имя, которое определяется его сигнатурой. Сигнатура метода включает в себя имя метода, тип получателя и список параметров. Операторы в Go также имеют фиксированное количество аргументов и не могут быть перегружены.
<br>Но есть возможность определения методов с одинаковым именем, если они принадлежат разным типам. Например:
<br>type Rectangle struct {
<br>    width, height float64
<br>}
<br>type Circle struct {
<br>    radius float64
<br>}
<br>func (r Rectangle) area() float64 {
<br>    return r.width * r.height
<br>}
<br>func (c Circle) area() float64 {
<br>    return math.Pi * c.radius * c.radius
<br>}
<h3>7. В какой последовательности будут выведены элементы map[int]int?</h3>
<br> Карты в go хранят данные в неупорядоченном виде, поскольку являются hash-таблицами. Это значит, что порядок хранения значений зависит от их hash-кода.
<h3>8. В чем разница make и new?</h3>
<br>Функция new не инициализирует объект, она только выделяет память для него.
<br>Функция make используется для создания слайсов, карт и каналов. Она выделяет память и инициализирует объекты.
<br>Функция new работает со всеми типами данных кроме канала и карты
<h3>9. Сколько существует способов задать переменную типа slice или map?</h3>
<br>Slice:
<br>1. s := []int{1, 2, 3}
<br>2. s := make([]int, 3)
<br>3. s := new([]int)
<br>4. var s []int
<br>Map:
<br>1. m := map[string]int{"one": 1, "two": 2, "three": 3}
<br>2. m := make(map[string]int)
<br>1 Способ позволяет создать и заполнить данными сразу в одной строке
<br>2 Способ позволяет создавать слайсы и карты с заданными емкостью и размером. Выделает память и возвращает указатель на нее.
<h3>10. Что выведет данная программа и почему?</h3>
<br>func update(p *int) {
<br>  b := 2
<br>  p = &b
<br>}

<br>func main() {
<br>  var (
<br>     a = 1
<br>     p = &a
<br>  )
<br>  fmt.Println(*p)
<br>  update(p)
<br>  fmt.Println(*p)
<br>}
<br>
<br>В функции main создается переменная a = 1 и указатель на нее p. Затем мы выводим значение переменной, на которую указывает p (то есть 1).
<br>В функции update создается переменная b = 2 и указатель на эту переменную присваивается p. Но это изменение не отразится на p снаружи функции, ведь новое значение мы не возвращаем и не работаем с памятью напрямую. Значение переменной a тоже не изменится.
<br>Поэтому в выводе мы увидим 1\n 1\n
<h3>11. Что выведет данная программа и почему?</h3>
<br>func main() {
<br>	wg := sync.WaitGroup{}
<br>	for i := 0; i < 5; i++ {
<br>		wg.Add(1)
<br>		go func(wg sync.WaitGroup, i int) {
<br>			fmt.Println(i)
<br>			wg.Done()
<br>		}(wg, i)
<br>	}
<br>	wg.Wait()
<br>	fmt.Println("exit")
<br>}
<br>
<br>Данная программа выведет: 0 1 2 3 4 и поймает panic(deadlock), поскольку wg.Done() влияет только на переданный wg функции, который является копией wg вне функции. То есть счетчик работающих горутин у основного wg не изменится, хотя все горутины закончили работу.
<h3>12. Что выведет данная программа и почему?</h3>
<br>func main() {
<br>  n := 0
<br>  if true {
<br>     n := 1
<br>     n++
<br>  }
<br>  fmt.Println(n)
<br>}
<br>
<br> Программа выведет 0, так как в блоке if объявлена новая перменная n, которой устанавливаем значение а затем инкрементируем. Но в основном блоке кода используется старая n, поэтому вывод 0
<h3>13. Что выведет данная программа и почему?</h3>
<br>func someAction(v []int8, b int8) {
<br>  v[0] = 100
<br>  v = append(v, b)
<br>}
<br>
<br>func main() {
<br>  var a = []int8{1, 2, 3, 4, 5}
<br>  someAction(a, 6)
<br>  fmt.Println(a)
<br>}
<br>
<br>Программа выведет 100 2 3 4 5. Вывод обусловлен тем, что операцией v[0] = 100 мы обращаемся к памяти и меняем значение в ней, а append пересоздает массив, из-за чего ссылка перебивается, а изменения вне функции не видны.
<h3>14. Что выведет данная программа и почему?</h3>
<br>func main() {
<br>  slice := []string{"a", "a"}
<br>
<br>  func(slice []string) {
<br>     slice = append(slice, "a")
<br>     slice[0] = "b"
<br>     slice[1] = "b"
<br>     fmt.Print(slice)
<br>  }(slice)
<br>  fmt.Print(slice)
<br>}
<br> Программа выведет два разных массива. Изначально выведется массив из анонимной функции, состоящий из 3-х эдементов b b a. Затем Выведется объявленный ранее массив a a. Вывод можно обосновать тем, что после функции append ссылка на объект в памяти перебивается, но это изменение затрагивает только аннонимную функцию, значение старого массива никак не изменятся